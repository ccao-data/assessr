% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cknn.R
\name{cknn}
\alias{cknn}
\title{Find comparable properties using clustered nearest neighbors}
\usage{
cknn(
  data,
  lon,
  lat,
  m = 5,
  k = 10,
  l = 0.5,
  var_weights = NULL,
  keep_data = TRUE,
  ...
)
}
\arguments{
\item{data}{A data frame containing the variables to cluster on. Should
contain both numerics and factors. Numerics should be unscaled. Lat/lon
should NOT be included.}

\item{lon}{A numeric vector of longitude values, reprojected into planar
coordinates specific to the target area. See
\href{https://geocompr.robinlovelace.net/reproj-geo-data.html}{here} for
details on reprojection using R.}

\item{lat}{A numeric vector of latitude values, reprojected into planar
coordinates specific to the target area. See
\href{https://geocompr.robinlovelace.net/reproj-geo-data.html}{here} for
details on reprojection using R.}

\item{m}{The number of clusters to create using the
\code{\link[clustMixType]{kproto}} function.}

\item{k}{The number of nearest neighbors to return for each row of
input data.}

\item{l}{Hyperparameter representing the trade-off between distance and
characteristics in kNN matching. Must be >= 0 and <= 1. Value equal to 1
will match on distance only, while value equal to 0 will disregard distance
and match on characteristics only. Default 0.5 (equal weight).}

\item{var_weights}{Value(s) passed to \code{lambda} input of
\code{\link[clustMixType]{kproto}}. See details.}

\item{keep_data}{Logical for whether original data should be included in the
returned object.}

\item{...}{Arguments passed on to \code{\link[clustMixType]{kproto}},
most commonly \code{iter.max}.}
}
\value{
Object of class \code{cknn} containing:

\item{kproto}{\code{\link[clustMixType]{kproto}} object containing
clusters, centroids, etc.}

\item{knn}{List of \code{k} nearest neighbors for each row in the
input data.}

\item{knn_idx}{Lookup for translating in-cluster index positions to
row indices from the input data. Used by predict method.}

\item{lon}{Unaltered input longitude vector. Used by predict method
for scaling new input data.}

\item{lat}{Unaltered input latitude vector. Used by predict method
for scaling new input data.}

\item{var_weights}{Unaltered variable weights used to construct the
cknn model.}

\item{m}{Number of clusters created by
\code{\link[clustMixType]{kproto}}.}

\item{k}{Number of nearest neighbors returned by
\code{\link[dbscan]{kNN}}.}

\item{l}{Hyperparameter used for distance/characteristics trade-off.}

\item{data}{Unaltered input data frame. Used by predict method for
scaling new input data. Only returned if \code{keep_data} is \code{TRUE}.}
}
\description{
Sales comparables are recent sales which have the same
(or very similar) characteristics as a target (unsold) property. They are
frequently used by assessors, real estate agents, and appraisers to
determine the fair market value of a home. However, finding comparable
properties at scale can be difficult.

This function can be used to quickly find comparables for any number of
unsold properties. It can also be used more generally to find similar
properties that are nearby each other, regardless of whether or not they
sold.

See the \href{https://ccao-data-science---modeling.gitlab.io/packages/assessr/articles/finding-sales-comps.html}{documentation site}
for example usage.
}
\details{
The \code{cknn} algorithm works in two stages:
\enumerate{
\item Divide the full set of sales into \code{m} clusters according to each
property's characteristics. This mimics the process of market segmentation
or separating properties into different classes. This clustering is done
using the k-prototypes function \code{\link[clustMixType]{kproto}} from
the \href{https://cran.r-project.org/web/packages/clustMixType/index.html}{clustMixType} library.
See \href{https://journal.r-project.org/archive/2018/RJ-2018-048/RJ-2018-048.pdf}{the clustMixType whitepaper}
for more information.
\item For each property \code{i}, find the \code{k} nearest neighbors within
\code{i}'s cluster, minimizing the distance over planar coordinates and
Euclidean distance to all cluster centers, This is accomplished with the
fast kNN function from \code{\link[dbscan]{kNN}}.
}

Options for inputs to \code{var_weights} include:
\itemize{
\item A named list with names corresponding to column names in the input data.
Names not included in the list are assumed to have a value of 1. These
named values are multiplied by the variance estimates created by
\code{\link[clustMixType]{lambdaest}}. Higher values will weight variables
more heavily during clustering.
\item A \code{p} long unnamed vector, where \code{p} is equal to the number
columns in the input data. These weights are not multiplied by the variance
estimates created by \code{\link[clustMixType]{lambdaest}}.
\item A single unnamed numeric value. This value trades off the relative
importance of numeric versus categorical variables. Higher values will
more heavily weight categorical variables, while a value of 0 replicates
standard k-means (numerics only).
\item A \code{NULL} value. This uses the default estimates produced by
\code{\link[clustMixType]{lambdaest}}. All variables are weighted equally.
}
}
\note{
Input data should be thoroughly cleaned. Outliers in numeric vectors
and factors with rare levels can both affect clustering performance.
Outlier values should be removed. Rare factor levels should be collapsed
into a single level or removed.
}
\seealso{
Other cknn: 
\code{\link{predict.cknn}()}
}
\concept{cknn}
