---
title: "Sales ratio study with real data"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

AssessR can easily be used with various data to conduct a sales ratio study. In this vignette, we demonstrate this process using real data from the Cook County Assessor's Office (CCAO). The CCAO publishes assessments and sales on the [Cook County Open Data Portal](https://datacatalog.cookcountyil.gov/stories/s/i22y-9sd2).

## Basics of sales ratio studies

A sales ratio is the ratio of the assessor's estimate of a property's value to the sale price of a property. A sales ratio study is a report on how accurately and fairly an assessor predicted property values. The CCAO has a [rigorous set of rules](https://github.com/ccao-data/wiki/blob/master/SOPs/Sales-Ratio-Studies.md) that govern how sales ratios studies are conducted.

In general, there are four important statistics produced in sales ratio studies, listed in the table below. It is important to understand that these statistics are calculated based on properties that sell. In most jurisdictions, the number of properties that sell in any single year is a very small percentage of the overall number of properties. In order to characterize the quality of the assessment role in a jurisdiction, we draw an inference from this small number of properties.

| Statistic               | Acceptable Range | Interpretation                                                                                                                                                                             |
|------------------------|------------------------|------------------------|
| COD                     | 5 - 15           | How often properties with the *same* sale price receive the same predicted market value. Lower CODs indicate more fairness between similarly priced properties.                            |
| PRD                     | .98 - 1.03       | How often properties with *different* sale prices receive the proportionately different predicted market values. Lower PRDs indicate more fairness between low and high-priced properties. |
| PRB                     | -.05 - .05       | PRB is a different approach to measuring fairness across homes with different sale prices.                                                                                                 |
| Median Assessment Ratio | .095 - 1.05      | The median ratio measures whether the most common ratios accurately reflect sale prices                                                                                                    |
| Sales Chasing (E.4)     | $\le$ 5%         | Measures the degree to which the statistics above are *true* reflections of the quality of assessments.                                                                                    |

### Interpretation of sales ratio statistics

Suppose you have a jurisdiction with a median ratio of one and a COD of 20. This indicates that, on average, the assessor predicts the sale price of properties accurately, but with a high dispersion. To use the dart board analogy, the assessor's darts fall in a wide area centered around the bullseye. On the other hand, if the median ratio is greater than one, and the COD is lower than 10, this indicates that the assessor consistently over-estimates the value of properties in their jurisdiction.

Suppose you have a jurisdiction with a low COD and high PRD & PRB. This indicates that the assessor consistently under-estimates higher value properties, and over-estimates lower value properties. Properties of similar value receive similar estimates, but there is structural inequality in the overall system.

Finally, suppose you have a jurisdiction with CODs, PRDs, and PRBs all within the acceptable range, but there is strong evidence of selective appraisals. In this case, the sales value statistics should be disregarded, since they are based on a non-random selection of the underlying set of properties. They cannot be used to characterize the quality of the assessment role.

## Loading data into R

There are many ways to load data into R. Below are some example methods:

### RSocrata

[RSocrata](https://github.com/Chicago/RSocrata) is a package developed by the City of Chicago to wrap Socrata API requests. It allows you to easily pass a Socrata app token, which will remove the API limit on the number of rows returned. Example usage is shown below. Replace the login details with your own.

```{r, eval=FALSE}
library(RSocrata)

# Load unlimited rows of assessment data, default is 1,000
assessments <- read.socrata(
  "https://datacatalog.cookcountyil.gov/resource/uzyt-m557.json",
  app_token = "YOURAPPTOKENHERE",
  email     = "user@example.com",
  password  = "fakepassword"
)
```

### jsonlite

Socrata can also return raw JSON if you manually construct a query URL. Follow the [API docs](https://dev.socrata.com/foundry/datacatalog.cookcountyil.gov/uzyt-m557) to alter your query. The raw JSON output can be read using the `read_json()` function from `jsonlite`.

```{r}
library(dplyr)
library(jsonlite)
library(stringr)

# Load 100k rows of 2020 residential (major class 2) assessment data
assessments <- read_json(
  paste0(
    "https://datacatalog.cookcountyil.gov/resource/uzyt-m557.json?",
    "$where=starts_with(class,'2')&year=2020&$limit=100000"
  ),
  simplifyVector = TRUE
)

# Load 100k rows of 2020 sales data
sales <- read_json(
  paste0(
    "https://datacatalog.cookcountyil.gov/resource/wvhk-k5uv.json?",
    "year=2020&$limit=100000"
  ),
  simplifyVector = TRUE
) %>%
  # read_json removes leading zeroes, add them back
  mutate(pin = str_pad(pin, 14, "left", "0"))
```

### From a CSV or Excel

R can also read Excel and CSV files stored on your computer.

```{r, eval=FALSE}
library(readxl)

# CSV files
assessments <- read.csv(
  file = "C:/Users/MEEE/Documents/.... where is your file ?"
)
sales <- read.csv(
  file = "C:/Users/MEEE/Documents/.... where is your file ?"
)

# Excel files
assessments <- read.csv(
  file = "C:/Users/MEEE/Documents/.... where is your file ?"
)
sales <- readxl::read_excel(
  file = "C:/Users/MEEE/Documents/.... where is your file ?",
  sheet = "your sheet"
)
```

### Connecting to a relational database

The CCAO's Data Science team uses Amazon Athena. R can connect to a wide range of database engines.

```{r, eval=FALSE}
library(noctua)
library(DBI)

# Connect to the database using a configured .Renviron file.
AWS_ATHENA_CONN_NOCTUA <- dbConnect(noctua::athena())

# Fetch data from the SQL server
assessments <- dbGetQuery(AWS_ATHENA_CONN_NOCTUA, paste0("
  SELECT * FROM [MY DATA TABLES]"))

# Disconnect DB connection
dbDisconnect(AWS_ATHENA_CONN_NOCTUA)
```

## Sales ratio study

In this section, we will use data published on the [Cook County Open Data Portal](https://datacatalog.cookcountyil.gov/Property-Taxation/Cook-County-Assessor-s-Residential-Assessments/uzyt-m557) to produce an example sales ratio study.

### Prepare the data

Above, we pulled assessment and sales data from the Open Data Portal. In order to produce our sales ratio statistics, our data needs to be formatted in 'long form,' meaning that each row is a property in a given year. The county provides *assessed value* on the Open Data Portal. For residential properties, we need to multiply assessed value by 10 to get fair market value. [Assessment levels](https://prodassets.cookcountyassessor.com/s3fs-public/form_documents/classcode.pdf) can differ for other classes.

```{r, results='asis', message=FALSE}
library(assessr)
library(dplyr)
library(tidyr)
library(knitr)

# Join the two datasets based on PIN, keeping only those that have assessed
# values AND sales
combined <- inner_join(
  assessments %>%
    select(pin, year, township_name, mailed_tot, certified_tot, board_tot),
  sales %>% select(pin, year, sale_price, is_multisale),
  by = c("pin", "year")
)

# Remove multisales, pivot to longer, then calculate the ratio for each property
# and assessment stage
combined <- combined %>%
  filter(is_multisale == FALSE) %>%
  pivot_longer(
    mailed_tot:board_tot,
    names_to = "stage",
    values_to = "assessed"
  ) %>%
  mutate_at(vars(sale_price, assessed), as.numeric) %>%
  mutate(ratio = (assessed * 10) / sale_price)
```

### Sales ratio statistics by township

Cook County has jurisdictions called townships that are important units for assessment. In the chunk below, we calculate sales ratio statistics for two townships.

```{r, results='asis', message=FALSE}
# For each town and stage, calculate COD, PRD, and PRB, and their respective
# confidence intervals then arrange by town name and stage of assessment
combined %>%
  filter(assessed > 0) %>%
  group_by(township_name, stage) %>%
  summarise(
    n = n(),
    cod = cod(ratio, na.rm = TRUE),
    cod_ci = paste(
      round(cod_ci(ratio, nboot = 1000, na.rm = TRUE), 3),
      collapse = ", "
    ),
    cod_met = cod_met(cod),
    prb = prb(assessed, sale_price, na.rm = TRUE),
    prb_ci = paste(
      round(prb_ci(assessed, sale_price, na.rm = TRUE), 3),
      collapse = ", "
    ),
    prb_met = prb_met(prb)
  ) %>%
  filter(n >= 70) %>%
  mutate(stage = factor(
    stage,
    levels = c("mailed_tot", "certified_tot", "board_tot")
  )) %>%
  arrange(township_name, stage) %>%
  rename_all(toupper) %>%
  kable(format = "markdown")
```

### Median ratios by sale price

Suppose you are concerned that an assessment role is unfair to lower value homes. One way to visually see whether ratios are systematically biased with respect to property value is to plot median ratios by decile. In our sample data, we can see each decile of sale price using the `quantile` function:

```{r, results='asis'}
library(DT)

data.frame(quantile(combined$sale_price, probs = 1:9 / 10)) %>%
  setNames("Sale Price") %>%
  tibble::rownames_to_column(var = "Decile") %>%
  DT::datatable(
    class = "cell-border stripe",
    rownames = FALSE,
    options = list(dom = "t")
  ) %>%
  formatCurrency("Sale Price", digits = 0)
```

Using these decile values, we can graph sales ratios across each decile of value. Here, we use the very useful `ggplot2` package to make an attractive graph.

```{r, results='asis', message=FALSE}
library(ggplot2)
library(scales)

# Prepare the data by getting the minimum and maximum sale price of each decile
graph_data <- combined %>%
  mutate(decile = ntile(sale_price, 10)) %>%
  group_by(decile) %>%
  mutate(decile_label = paste(
    dollar(min(sale_price) / 1000, accuracy = 1, suffix = "K"),
    dollar(max(sale_price) / 1000, accuracy = 1, suffix = "K"),
    sep = " - "
  )) %>%
  mutate(decile_label = ifelse(decile == 10, "$760K+", decile_label)) %>%
  mutate(decile_label = forcats::fct_reorder(decile_label, decile)) %>%
  group_by(decile_label) %>%
  summarise(
    n = n(),
    `Median Sales Ratio` = median(ratio)
  ) %>%
  dplyr::filter(n > 70)

# Create a plot of sales ratio by decile
ggplot(graph_data) +
  geom_point(aes(x = decile_label, y = `Median Sales Ratio`), size = 3) +
  scale_y_continuous(labels = function(x) paste0(x * 100, "%")) +
  labs(
    title = "Median Sale Ratios: Open Data Sample ",
    subtitle = "By decile of sale price in 2020",
    x = "", y = ""
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 1),
    legend.position = "bottom"
  )
```

### Detecting selective appraisals

Selective appraisal, sometimes referred to as sales chasing, happens when a property is reappraised to shift its assessed value toward its actual sale price. The CCAO requires selective appraisal detection in every sales ratio study. This is because selective appraisal renders all other sales ratio statistics suspect. In the code below, we construct two sets of ratios, one normally distributed, and one 'chased.'

```{r, message=FALSE, warning=FALSE, results='asis', fig.height=4}
# Generate distributions of fake ratios, including one with "sales chasing"
normal_ratios <- c(rnorm(1000, 1, 0.15))
chased_ratios <- c(rnorm(900, 1, 0.15), rep(1, 100))

# Plot the CDFs of each vector. Notice the flat spot on the red CDF
ggplot() +
  stat_ecdf(data = data.frame(x = normal_ratios), aes(x), color = "blue") +
  stat_ecdf(data = data.frame(x = chased_ratios), aes(x), color = "red") +
  geom_vline(xintercept = 0.98) +
  geom_vline(xintercept = 1.02) +
  xlim(0.7, 1.3) +
  labs(x = "Ratio", y = "F(x)") +
  theme_minimal()

# Detect chasing for each vector
tibble(
  "Blue Chased?" = detect_chasing(normal_ratios),
  "Red Chased?" = detect_chasing(chased_ratios)
) %>%
  kable(format = "markdown", digits = 3)
```

Ratios that include selective appraisals will be clustered around the value of one much more than ratios produced from a CAMA system. We can see this visually in the graph where the cumulative distribution curve shows a discontinuous jump, or 'flat spot', near one.


### GINI Based Measure of Vertical Equity

Another way to test the vertical equity of assessments is by looking at the differences in the GINI coefficient, a widely used metric to analyze inequality. The first step in this process is to order the data by sale price. Once done, the GINI coefficient is calculated for both sale and assessed value (both ordered by sale price). A graph of the Lorenz Curve is presented below.


```{r}
GINI_data <- combined %>%
  select(sale_price, assessed) %>%
  arrange(sale_price)

sale_price <- GINI_data$sale_price
assessed <- GINI_data$assessed

lorenz_data_price <- data.frame(
  Percentage = c(0, cumsum(sale_price) / sum(sale_price)),
  CumulativePercentage = c(0, seq_along(sale_price)) / length(sale_price)
)

lorenz_data_assessed <- data.frame(
  Percentage = c(0, cumsum(assessed) / sum(assessed)),
  CumulativePercentage = c(0, seq_along(assessed)) / length(assessed)
)

Lorenz_Curves <- ggplot() +
  geom_line(
    data = lorenz_data_price,
    aes(x = CumulativePercentage, y = Percentage), color = "blue"
  ) +
  geom_line(
    data = lorenz_data_assessed,
    aes(x = CumulativePercentage, y = Percentage), color = "red"
  ) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "green") +
  geom_text(
    data = data.frame(x = 0.8, y = 0.1, label = "Sale Price"),
    aes(x, y, label = label), color = "blue", vjust = 1
  ) +
  geom_text(
    data = data.frame(x = 0.8, y = 0.05, label = "Assessed Price"),
    aes(x, y, label = label), color = "red", hjust = .34, vjust = 1
  ) +
  labs(
    title = "Lorenz Curve for Sale and Assessed Values",
    x = "Percentage of Houses",
    y = "Percentage of Value"
  ) +
  theme_minimal()

print(Lorenz_Curves)
```



In this graphic, the green line (Line of Equity) represents a hypothetical environment, where housing valuations are completely equitable. The two other curves represent the percentage of value (y axis), encompassed by an increasing percentage of housing (x-axis). Since housing is ordered by sale prices, the rate of increase is increasing. 

What this chart shows is that for the vast majority of the income distribution, assessed values are closer to the Line of Equity. This can be interpreted two ways. 

1st, when the assessed line is above the sale price, the gap between the the two lines at any individual point, represents the cumulative over-assessment for all houses at that value or below.

2nd, it means that the GINI coefficient for sale price is going to be higher than the GINI coefficient for assessed price. 

In this situation, the two curves represent a regressive housing policy. This is not immediately intuitive, but to conceptualize this, think of an exaggerated "progressive" policy, where all houses were valued at $0 with one house encompassing all the assessed value. In this distribution, curve would be at 0 until the final house, where it would jump to 100% of the cumulative value (a GINI of 1). Thus, a higher GINI represents a more progressive assessment policy. 

To translate these curves to a metric, the Kakwani and Modified Kakwani Index are used. These are straightforward, with the following definitions:

Kakwani Index: Assessed GINI - Price GINI

Modified Kakwani Index: Assessed GINI / Price GINI

```{r}
n <- length(assessed)
# Calculate the sum of the n elements of the assessed_price vector.
G_assessed <- sum(assessed * 1L:n)

# Compute the Gini Coefficient based on the previously calculated sum
# and the increasing sum of all elements in the assessed_price vector.
G_assessed <- 2 * G_assessed / sum(assessed) - (n + 1L)

# Normalize the Gini coefficient by dividing it by n.
GINI_assessed <- G_assessed / n

# Same process for Sale
# This will match Gini(sale_price) in the ineq package.
G_sale <- sum(sale_price * 1L:n)
G_sale <- 2 * G_sale / sum(sale_price) - (n + 1L)
GINI_sale <- G_sale / n

MKI <- GINI_assessed / GINI_sale
KI <- GINI_assessed - GINI_sale

print(MKI)
print(KI)
```

The output for the Modified Kakwani Index is .9413, and the Kakwani Index is -.0197. According to the following table, this means that the assessment policy is regressive. 

| Range              | Interpretation     |
|--------------------|--------------------|
| Kakwani Index      |                    |
| < 0                | Regressive Policy  |
| = 0                | Vertical Equity    |
| > 0                | Progressive Policy |
| Modified Kakwani Index |                  |
| < 1                | Regressive Policy  |
| = 1                | Vertical Equity    |
| > 1                | Progressive Policy |
